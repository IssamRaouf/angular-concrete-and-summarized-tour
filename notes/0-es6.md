#### Let
* let est un ajout très important du langage javascript dans ES6.
* Ce n'est pas un remplacement pour  var, var peut toujours être utilisé même dans ES6 et a la même sémantique que ES5.
* Cependant, à moins que vous n'ayez une raison particulière d'utiliser var, 
 toutes les variables que vous définissez désormais doivent être utilisées let.
#### const 
* const permet de déclarer des variables qui ne changent pas dans le temps, qui sont immuables.
* Le problème important avec const est que la variable est immuable, mais pas la valeur, ce que la variable pointe vers.
* Cela signifie que si nous déclarons un objet comme étant une  constsource de confusion, nous pouvons toujours modifier les propriétés de cet objet ultérieurement.
#### Template String
Les chaînes de modèles constituent une petite modification de JavaScript dans ES6,
 mais la commodité des chaînes multilignes et de la substitution de variables est considérable.
#### Arrow functions
La nouvelle syntaxe de la grosse flèche dans ES6 est bien plus qu'un moyen légèrement plus court d'écrire des fonctions anonymes.
#### Destructuring
La destruction est une fonctionnalité utile de ES6. Elle permet 
d’extraire facilement des valeurs d’objets et de tableaux.
Grâce à la destruction des paramètres de fonction, nous avons maintenant une syntaxe intégrée pour fournir des paramètres facultatifs aux fonctions, 
y compris leur attribuer des valeurs par défaut si aucun n’est fourni.
####  for-of
* La  for–in boucle sert à boucler sur les propriétés de l'objet.

* La  for–of boucle sert à boucler sur les valeurs d'un tableau.

* for–of n'est pas juste pour les tableaux. Il fonctionne également sur la plupart des objets de type tableau,
 y compris les nouveaux types Setet  Maptypes que nous couvrirons dans la prochaine leçon.
#### Map & set

* Map et Set sont d'excellents ajouts à JavaScript dans ES6.

* Nous n’avons plus à nous occuper de Map et de l’objet pauvre cousin , c’est son inconvénient.
exmeple:

```
let map = new Map();
map.set("A", 1);
map.set("B", 2);
map.set("C", 3);

let map2 = new Map()
  .set("A", 1)
  .set("B", 2)
  .set("C", 3);

let map3 = new Map([
  ["A", 1],
  ["B", 2],
  ["C", 3]
]);

for (let [key, value] of map) {
  console.log(key, value);
}

console.log(map.get("A"));
console.log(map.has("A"));
console.log(map.size);

map.delete("A");
console.log(map.size);

map.clear();
console.log(map.size);


// Set
let set = new Set();
set.add('APPLE');
set.add('ORANGE');
set.add('MANGO');


let set2 = new Set()
  .add('APPLE')
  .add('ORANGE')
  .add('MANGO');

let set3 = new Set(['APPLE', 'ORANGE', 'MANGO']);

console.log(set.has('APPLE'));

set.delete('APPLE');

console.log(set.size);

set.clear();
console.log(set.size);


let set4 = new Set();
set3.add('Moo');
console.log(set3.size);
// 1
set4.add('Moo');
console.log(set4.size);
// 1

for (let entry of set2) {
  console.log(entry);
}
```
#### Promisses
* Les promesses sont une solution bien plus propre à l'écriture de code asynchrone que les rappels.

* Le code ainsi créé est plus facile à lire et est souvent écrit dans l’ordre exécuté par l’application.

* Il peut donc être plus facile de tracer un code dans votre tête.

* Avec le  catch gestionnaire, cela nous donne également un endroit unique où nous pouvons gérer les erreurs.

exemple:

```
// Via callbacks
/*
 function doAsyncTask(cb) {
 setTimeout(() => {
 console.log("Async Task Calling Callback");
 cb();
 }, 1000);
 }
 doAsyncTask(() => console.log("Callback Called"));
 */



// Via Promise
let error = false;
function doAsyncTask() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (error) {
        reject('error');
      } else {
        resolve('done');
      }
    }, 1000);
  });
}

doAsyncTask().then(
    (val) => console.log(val),
    (err) => console.error(err)
);

// Immediately Resolved Promise
let promise = Promise.resolve('done');
promise.then((val) => console.log(val)); // 'done'

// Handling Errors
Promise.resolve('done')
    .then((val) => {throw new Error("fail")})
    .then((val) => console.log(val))
    .catch((err) => console.error(err));
```
#### Class & interface
* Dans ES6, nous avons maintenant une nouvelle façon d'écrire du code orienté objet avec la  classsyntaxe.

* Nous pouvons hériter des méthodes et propriétés d'une classe dans une autre en utilisant le extendsmot -  clé.

* Sous le capot, nous utilisons toujours un héritage basé sur un prototype, mais la syntaxe est plus facile à comprendre et plus familière pour les développeurs venant d'autres langages.

* Tapuscrit ajoute quelques fonctionnalités supplémentaires en haut des classes ES6, comme  modificateurs d'accès et  interfaces
exemple:
```
interface Human {
  firstName: string;
  lastName: string;
  name?: Function;
  isLate?(time: Date): Function;
}

class Person implements Human {
  constructor(public firstName, public lastName) {
  }

  public name() {
    return `${this.firstName} ${this.lastName}`;
  }

  protected whoAreYou() {
    return `Hi i'm ${this.name()}`;
  }
}

class Student extends Person {
  constructor(public firstName, public lastName, public course) {
    super(firstName, lastName);
  }

  whoAreYou() {
    return `${super.whoAreYou()} and i'm studying ${this.course}`;
  }
}

let asim = new Student("Asim", "Hussain", "typescript");
console.log(asim.whoAreYou());
```
### Decorator 
* Les décorateurs sont une nouvelle fonctionnalité de TypeScript et sont utilisés dans le code angulaire, mais ils ne doivent en aucun cas être effrayés.

* Avec les décorateurs, nous pouvons configurer et personnaliser nos classes au moment de la conception.

* Ce ne sont que des fonctions qui peuvent être utilisées pour ajouter des méta-données, des propriétés ou des fonctions à la chose à laquelle elles sont attachées.

```
function Student(config) {
  return function (target) {
    Object.defineProperty(target.prototype, 'course', { value: () => config.course })
  }
}



@Student({
  course: "angular3"
})
class Person {
  constructor(private firstName, private lastName) {
  }

  public name() {
    return `${this.firstName} ${this.lastName}`;
  }

  protected whoAreYou() {
    return `Hi i'm ${this.name()}`;
  }
}

let iraouf = new Person("issam", "Raouf");
//noinspection TypeScriptUnresolvedFunction
console.log(iraouf.course());
```
### Modules
* Avec les modules ES6, nous disposons enfin d’un mécanisme permettant à la langue de charger pour nous les fichiers dépendants.
* Ce n'est pas encore cuit dans les moteurs javascript. Donc, pour résoudre ce problème dans Angular,
 nous utilisons toujours la syntaxe de chargement du module ES6, mais laissons le soin à TypeScript de le transpiler en CommonJS.
```
// export

export function square(x) {
    return Math.pow(x, 2)
}
export function cow() {
    console.log("Mooooo!!!")
}

// import
import * as utils from './utils';
console.log(utils.square(4));
utils.cow();

```
### Types Typecript
####Types de base:
* let decimal: number = 6;
* let done: boolean = false;
* let color: string = "blue";
#### Tableaux
* let list: number[] = [1, 2, 3];
* générique : let list: Array<number> = [1, 2, 3];

#### Functions 
* let fun: Function = () => console.log("Hello");
#### Enum

enum Direction {
    Up,
    Down,
    Left,
    Right
}

let go: Direction;
go = Direction.Up;

#### Assertion de type

1) (<string>value) indique à TypeScript que nous croyons que le type de valeur est une chaîne.

* let value: any = 'issam raouf';
* let length: number = (<string>value).length;

#### Génériques
```
// Probleme
class AudioPost {
    content: Audio;
}

class VideoPost {
    content: Video;
}

class LinkPost {
    content: Link;
}

class TextPost {
    content: Text;
}
 
//Solution

class Audio {}
class Video {}
class Link {}
class Text {}

class Post<T> {
    content: T;
}

let videoPost: Post<Video>;
```

#### Resume Types :
* Avec la vérification de type de temps de transfert, TypeScript peut aider à détecter les bogues beaucoup plus tôt et plus rapidement que s'ils se manifestaient au moment de l'exécution.

* L'utilisation de types est facultative mais fortement recommandée par l'équipe angulaire.

* Si vous utilisez des bibliothèques tierces déjà transpilées en javascript, typescript peut toujours effectuer une vérification de type en temps de transpile si nous incluons le fichier de définition de type pour la bibliothèque.

