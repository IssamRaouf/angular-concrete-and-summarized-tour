#### Let
* let est un ajout très important du langage javascript dans ES6.
* Ce n'est pas un remplacement pour  var, var peut toujours être utilisé même dans ES6 et a la même sémantique que ES5.
* Cependant, à moins que vous n'ayez une raison particulière d'utiliser var, 
 toutes les variables que vous définissez désormais doivent être utilisées let.
#### const 
* const permet de déclarer des variables qui ne changent pas dans le temps, qui sont immuables.
* Le problème important avec const est que la variable est immuable, mais pas la valeur, ce que la variable pointe vers.
* Cela signifie que si nous déclarons un objet comme étant une  constsource de confusion, nous pouvons toujours modifier les propriétés de cet objet ultérieurement.
#### Template String
Les chaînes de modèles constituent une petite modification de JavaScript dans ES6,
 mais la commodité des chaînes multilignes et de la substitution de variables est considérable.
#### Arrow functions
La nouvelle syntaxe de la grosse flèche dans ES6 est bien plus qu'un moyen légèrement plus court d'écrire des fonctions anonymes.
#### Destructuring
La destruction est une fonctionnalité utile de ES6. Elle permet 
d’extraire facilement des valeurs d’objets et de tableaux.
Grâce à la destruction des paramètres de fonction, nous avons maintenant une syntaxe intégrée pour fournir des paramètres facultatifs aux fonctions, 
y compris leur attribuer des valeurs par défaut si aucun n’est fourni.
####  for-of
* La  for–in boucle sert à boucler sur les propriétés de l'objet.

* La  for–of boucle sert à boucler sur les valeurs d'un tableau.

* for–of n'est pas juste pour les tableaux. Il fonctionne également sur la plupart des objets de type tableau,
 y compris les nouveaux types Setet  Maptypes que nous couvrirons dans la prochaine leçon.
#### Map & set

* Map et Set sont d'excellents ajouts à JavaScript dans ES6.

* Nous n’avons plus à nous occuper de Map et de l’objet pauvre cousin , c’est son inconvénient.
exmeple:

```
let map = new Map();
map.set("A", 1);
map.set("B", 2);
map.set("C", 3);

let map2 = new Map()
  .set("A", 1)
  .set("B", 2)
  .set("C", 3);

let map3 = new Map([
  ["A", 1],
  ["B", 2],
  ["C", 3]
]);

for (let [key, value] of map) {
  console.log(key, value);
}

console.log(map.get("A"));
console.log(map.has("A"));
console.log(map.size);

map.delete("A");
console.log(map.size);

map.clear();
console.log(map.size);


// Set
let set = new Set();
set.add('APPLE');
set.add('ORANGE');
set.add('MANGO');


let set2 = new Set()
  .add('APPLE')
  .add('ORANGE')
  .add('MANGO');

let set3 = new Set(['APPLE', 'ORANGE', 'MANGO']);

console.log(set.has('APPLE'));

set.delete('APPLE');

console.log(set.size);

set.clear();
console.log(set.size);


let set4 = new Set();
set3.add('Moo');
console.log(set3.size);
// 1
set4.add('Moo');
console.log(set4.size);
// 1

for (let entry of set2) {
  console.log(entry);
}
```
#### Promisses
* Les promesses sont une solution bien plus propre à l'écriture de code asynchrone que les rappels.

* Le code ainsi créé est plus facile à lire et est souvent écrit dans l’ordre exécuté par l’application.

* Il peut donc être plus facile de tracer un code dans votre tête.

* Avec le  catch gestionnaire, cela nous donne également un endroit unique où nous pouvons gérer les erreurs.

exemple:

```
// Via callbacks
/*
 function doAsyncTask(cb) {
 setTimeout(() => {
 console.log("Async Task Calling Callback");
 cb();
 }, 1000);
 }
 doAsyncTask(() => console.log("Callback Called"));
 */



// Via Promise
let error = false;
function doAsyncTask() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (error) {
        reject('error');
      } else {
        resolve('done');
      }
    }, 1000);
  });
}

doAsyncTask().then(
    (val) => console.log(val),
    (err) => console.error(err)
);

// Immediately Resolved Promise
let promise = Promise.resolve('done');
promise.then((val) => console.log(val)); // 'done'

// Handling Errors
Promise.resolve('done')
    .then((val) => {throw new Error("fail")})
    .then((val) => console.log(val))
    .catch((err) => console.error(err));
```
#### Class & interface
* Dans ES6, nous avons maintenant une nouvelle façon d'écrire du code orienté objet avec la  classsyntaxe.

* Nous pouvons hériter des méthodes et propriétés d'une classe dans une autre en utilisant le extendsmot -  clé.

* Sous le capot, nous utilisons toujours un héritage basé sur un prototype, mais la syntaxe est plus facile à comprendre et plus familière pour les développeurs venant d'autres langages.

* Tapuscrit ajoute quelques fonctionnalités supplémentaires en haut des classes ES6, comme  modificateurs d'accès et  interfaces
exemple:
```
interface Human {
  firstName: string;
  lastName: string;
  name?: Function;
  isLate?(time: Date): Function;
}

class Person implements Human {
  constructor(public firstName, public lastName) {
  }

  public name() {
    return `${this.firstName} ${this.lastName}`;
  }

  protected whoAreYou() {
    return `Hi i'm ${this.name()}`;
  }
}

class Student extends Person {
  constructor(public firstName, public lastName, public course) {
    super(firstName, lastName);
  }

  whoAreYou() {
    return `${super.whoAreYou()} and i'm studying ${this.course}`;
  }
}

let asim = new Student("Asim", "Hussain", "typescript");
console.log(asim.whoAreYou());
```
